-module(apply).

%% 内置函数apply(Mod, Func, [Arg1, Arg2, ..., ArgN])将模块Mod的Func函数应用到这些参数上.
%% 等价于 Mod:Func(Arg1, Arg2, ..., ArgN).
%% 他与直接调用函数的区别是他是动态计算得出的.

%% 算术表达式
%% + - * / bnot div rem band bor bxor bsl bsr

%% 元数
%% 函数的元数是函数拥有的参数数量,同一个函数两个名称相同但元数不同的函数是完全不同的函数
%% 如 sum([], N) -> N;
%% sum(List, N) -> sum(List -- [], N).
%% 尾递归经常使用这个函数.

%% 属性
%% 预定义模块属性 -module() 和 -import()
%% -export(Options)和 -vsn(Version)

%% 用户定义模块属性
%% -SomeTag(Value) SomeTag是一个院子,Value是一个字面数据类型

%% 块表达式 当语法需要某单个表达式,但我们相用一个表达式序列就可以用begin ... end 返回最后一个

%% 布尔表达式
%% not 逻辑非 andalso 逻辑与 orelse 逻辑或 xor 逻辑异或

%% 注释 没有块注释,erlang的注释从一个百分号%开始

%% 动态代码载入,每当调用someModule:someFunctio()时,调用的总是最新函数
%% 假设一个循环不断输出变量A,当我们修改完这段代码并调用模块的这个函数时就会自动加载最新的改动

%% 假设编译三次:三次情况如下
%% 第一次 : 启动第一版代码进程
%% 第二次 : 使用第一版代码和第二版代码进程同时运行,他们同时用第二版的代码运行
%% 第三次 : 使用第三版和第二版的代码进程同时运行,同时用第三版的代码,第一版代码的进程中断

%% erlang预处理器: erlang模块在编译前会自动由erlang的预处理器进行处理,预处理器会展开源文件里所有的宏并插入必要包含文件

%% 转义序列:在字符串和带引号的原子里用转义序列输入不可打印字符

%% 表达式和表达式序列,任何可执行并生成值的事务叫表达式.
%% 表达式序列,在->箭头后随处可见由逗号隔开每个表达式.

%% 函数引用

%% 例子可以用 fun mod:func/1 直接调用函数.

%% 包含文件 -include(Filename).

%% -include_lib(?Nanme).编译器会正确的找到包含文件.

%% 列表操作 : ++ -- 最常用,列表之间++ 后面列表附加到前面的列表
%% 列表之间 -- 前面列表的和后面列表相同元素都会去除.

%% 宏 -define(A, B) ?A会展开宏变成B.
%% ?FILE:当前文件名 ?MODULE:当前模块名 ?LINE当前行号

%% -undef()取消某个宏定义
%% -ifdef()只有宏定义过某文件才执行后代码
%% -ifndef()只有没有宏定义过才执行后面代码
%% -else只用在ifdef或ifndef后,如果条件为否则else后语句将执行
%% -endif标记ifdef和idndef语句的结尾

%% K进制整数用K#Digits写法,如二进制2#00101010,或把一个十六进制数写成16#af6bfa23
%% $写法:$C 等同于 ASCLL字符的C整数代码 

%% 浮点数:由符号,整数,小数点,分数部分和指数部分组成

%% 进程字典,每个进程都有一个进程字典.

%% 引用是一种全局唯一的Erlang由内置函数erlang:make_ref()创建

%% 短路表达式andalso,orelse和and,or的区别:
%% and和or都会把两个表达式跑一遍,但是andalso和orelse会先执行一个再判断

%% 元组模块M:f(),M不仅可以是一个模块名也可以是一个{Mod, X1, X2, Xn}的元组,他调用的元组就是Mod:f(X1, X2, Xn)

%% 下划线变量:不关心变量,也即是你不会使用的变量.








